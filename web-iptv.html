<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Player</title>
    <link rel="icon" type="image/png" href="assets/icon.png">
    <link rel="apple-touch-icon" href="assets/icon.png">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js@latest/dist/mpegts.js"></script>
    <!-- AC-3 Audio Support Notice -->
    <script>
        console.log('🎵 IPTV Player: AC-3 audio support will use browser fallback');
        console.log('💡 Note: AC-3 audio may not work in all browsers due to codec licensing');
    </script>
    <!-- Config will be loaded dynamically if available -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #121212;
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a1a;
            padding: 1rem 2rem;
            border-bottom: 1px solid #333;
        }

        .header h1 {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 2rem;
            font-weight: 300;
            margin: 0;
        }

        .title-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .keyboard-help {
            background: #2a2a2a;
            padding: 0.5rem 2rem;
            border-bottom: 1px solid #333;
            text-align: center;
        }

        .help-text {
            color: #888;
            font-size: 0.85rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn-icon {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon:hover {
            background: #3a3a3a;
            border-color: #1db954;
            transform: scale(1.05);
        }

        .control-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .btn {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #444;
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #1db954;
            border: none;
            box-shadow: 0 4px 15px rgba(29, 185, 84, 0.3);
        }

        .btn-primary:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(29, 185, 84, 0.3);
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .epg-panel {
            width: 350px;
            background: #1a1a1a;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .epg-panel.collapsed {
            width: 0;
            overflow: hidden;
        }

        .epg-header {
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .epg-header h3 {
            color: #1db954;
            font-size: 1.1rem;
            margin: 0;
        }

        .epg-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .epg-refresh {
            background: #1db954;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .epg-refresh:hover {
            background: #1ed760;
        }

        .epg-refresh:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .epg-toggle {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .epg-toggle:hover {
            background: #444;
        }

        .epg-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .epg-channel-info {
            margin-bottom: 1rem;
            padding: 1rem;
            background: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .epg-channel-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1db954;
            margin-bottom: 0.5rem;
        }

        .epg-current-programme {
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid rgba(74, 222, 128, 0.3);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .epg-current-programme h4 {
            color: #4ade80;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .epg-programme-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .epg-programme-item {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s ease;
        }

        .epg-programme-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .epg-programme-item.current {
            background: rgba(74, 222, 128, 0.1);
            border-left: 3px solid #4ade80;
        }

        .epg-programme-time {
            font-size: 0.8rem;
            color: #a0a0a0;
            margin-bottom: 0.25rem;
        }

        .epg-programme-title {
            font-size: 0.9rem;
            color: #ffffff;
            font-weight: 500;
        }

        .epg-loading {
            text-align: center;
            color: #a0a0a0;
            padding: 2rem;
        }

        .epg-error {
            text-align: center;
            color: #ff4757;
            padding: 2rem;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #1a1a1a;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-header h3 {
            color: #1db954;
            font-size: 1.1rem;
            margin: 0;
        }

        .settings-close {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .settings-close:hover {
            background: #444;
        }

        .settings-content {
            padding: 1rem;
        }

        .settings-section {
            margin-bottom: 2rem;
        }

        .settings-section h4 {
            color: #1db954;
            font-size: 1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #333;
            padding-bottom: 0.5rem;
        }

        .settings-group {
            margin-bottom: 1rem;
        }

        .settings-label {
            display: block;
            color: #ccc;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .settings-input {
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .settings-input:focus {
            outline: none;
            border-color: #1db954;
        }

        .settings-input::placeholder {
            color: #999;
        }

        .settings-button {
            background: #1db954;
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .settings-button:hover {
            background: #1ed760;
        }

        .settings-button.secondary {
            background: #333;
            border: 1px solid #555;
        }

        .settings-button.secondary:hover {
            background: #444;
        }

        /* Samples Modal */
        .samples-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .sample-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sample-item:hover {
            background: #333;
            border-color: #1db954;
            transform: translateY(-2px);
        }

        .sample-icon {
            font-size: 2rem;
            margin-right: 1rem;
            min-width: 3rem;
            text-align: center;
        }

        .sample-info h4 {
            margin: 0 0 0.5rem 0;
            color: #1db954;
            font-size: 1.1rem;
        }

        .sample-info p {
            margin: 0;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }

        .settings-overlay.open {
            display: block;
        }

        .video-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            margin: 1rem;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #333;
        }

        .video-container {
            position: relative;
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video-player {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .player-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
        }

        .player-overlay h3 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        .player-overlay p {
            color: #a0a0a0;
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
        }

        .video-controls {
            padding: 1rem;
            background: #2a2a2a;
            border-top: 1px solid #333;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-control {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

        .channels-section {
            flex: 1;
            background: #1a1a1a;
            margin: 1rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            border: 1px solid #333;
            max-height: calc(100vh - 200px);
        }

        .channels-header {
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .channels-header h2 {
            color: #1db954;
            font-size: 1.3rem;
            font-weight: 300;
        }

        .search-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .search-input {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            min-width: 200px;
        }

        .search-input::placeholder {
            color: #999;
        }

        .channels-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            max-height: calc(100vh - 300px);
        }

        .channel-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #333;
        }

        .channel-item:hover {
            background: #333;
            transform: translateX(5px);
        }

        .channel-item.active {
            background: rgba(29, 185, 84, 0.2);
            border-color: #1db954;
        }

        .channel-item.selected {
            background: #1db954;
            border-color: #1db954;
            color: #000;
            transform: translateX(8px);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }

        .channel-item.selected .channel-name {
            color: #000;
            font-weight: bold;
        }

        .channel-item.selected .channel-group {
            color: #333;
        }

        .channel-logo {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            margin-right: 0.75rem;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        .channel-logo img {
            max-width: 60px;
            max-height: 60px;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        .channel-info {
            flex: 1;
        }

        .channel-name {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .channel-group {
            font-size: 0.8rem;
            color: #a0a0a0;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #a0a0a0;
        }

        .empty-state p {
            font-size: 1.1rem;
        }

        .status-bar {
            background: #1a1a1a;
            padding: 0.75rem 2rem;
            border-top: 1px solid #333;
            font-size: 0.9rem;
            color: #999;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff4757;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
            z-index: 1001;
            display: none;
            max-width: 400px;
        }

        .load-menu {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 8px;
            min-width: 200px;
            z-index: 1000;
            display: none !important;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .dropdown-menu.show {
            display: block !important;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid #333;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #333;
        }

        .dropdown-icon {
            margin-right: 0.75rem;
            font-size: 1.1rem;
        }

        .dropdown-text {
            font-size: 0.9rem;
        }

        .file-input-container {
            position: relative;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .file-input-label:hover {
            background: #444;
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .epg-panel {
                width: 100%;
                height: 300px;
            }
            
            .channels-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-input {
                min-width: auto;
                width: 100%;
            }
        }
    </style>
</head>
<body>
        <div class="header">
            <h1>
                <img src="assets/icon.png" alt="IPTV" class="title-icon">
                IPTV Player
            </h1>
            <div class="controls">
                <div class="load-menu">
                    <button id="load-btn" class="btn-icon" title="Load Playlist">
                        <img src="assets/load-icon.svg" alt="Load" class="control-icon">
                    </button>
                    <div id="load-dropdown" class="dropdown-menu">
                        <div class="dropdown-item" data-action="upload">
                            <span class="dropdown-icon">📤</span>
                            <span class="dropdown-text">Upload M3U File</span>
                        </div>
                        <div class="dropdown-item" data-action="default">
                            <span class="dropdown-icon">🔄</span>
                            <span class="dropdown-text">Default Playlist</span>
                        </div>
                        <div class="dropdown-item" data-action="samples">
                            <span class="dropdown-icon">📺</span>
                            <span class="dropdown-text">Sample Playlists</span>
                        </div>
                    </div>
                </div>
                <button id="settings-btn" class="btn-icon" title="Settings">
                    <img src="assets/settings-icon.svg" alt="Settings" class="control-icon">
                </button>
            </div>
        </div>
        
        <div class="keyboard-help">
            <span class="help-text">⌨️ Use arrow keys or space to navigate channels • Enter to play</span>
        </div>

    <div class="main-content">
        <section class="video-section">
            <div class="video-container">
                <video id="video-player" controls>
                    <p>Your browser doesn't support HTML5 video.</p>
                </video>
                <div class="player-overlay" id="player-overlay">
                    <h3>🎬 Stream Ready</h3>
                    <p>Select a channel from the list to start streaming. The player will automatically detect and use the best streaming technology for your content.</p>
                </div>
            </div>
            <div class="video-controls">
                <button id="play-pause-btn" class="btn btn-control">⏸️ Pause</button>
                <button id="mute-btn" class="btn btn-control">🔇 Mute</button>
                <button id="fullscreen-btn" class="btn btn-control">⛶ Fullscreen</button>
                <button id="native-player-btn" class="btn btn-control" title="Open in native media player">🎬 Native Player</button>
            </div>
        </section>

        <section class="channels-section">
            <div class="channels-header">
                <h2>📋 Channels</h2>
                <div class="search-container">
                    <input type="text" id="search-input" placeholder="Search channels..." class="search-input">
                </div>
            </div>
            
            <div id="channels-container" class="channels-container">
                <div class="empty-state">
                    <p>📁 Load an M3U file to see channels</p>
                </div>
            </div>
        </section>

        <section class="epg-panel" id="epg-panel">
            <div class="epg-header">
                <h3>📺 EPG Guide</h3>
                <div class="epg-controls">
                    <button class="epg-refresh" id="epg-refresh" title="Refresh EPG data">
                        <img src="assets/refresh-icon.svg" alt="Refresh" style="width: 16px; height: 16px;">
                    </button>
                    <button class="epg-toggle" id="epg-toggle">Hide</button>
                </div>
            </div>
            <div class="epg-content" id="epg-content">
                <div class="epg-loading">
                    <p>Select a channel to view EPG</p>
                </div>
            </div>
        </section>
    </div>

    <div class="status-bar">
        <span id="status-text">Ready - Load an M3U file to start</span>
    </div>

    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p id="loading-text">Loading...</p>
        </div>
    </div>

    <div class="error-message" id="error-message">
        <span class="error-text"></span>
    </div>

    <!-- Settings Panel -->
    <div class="settings-overlay" id="settings-overlay"></div>
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <h3>⚙️ Settings</h3>
            <button class="settings-close" id="settings-close">✕</button>
        </div>
        <div class="settings-content">
            <div class="settings-section">
                <h4>📁 M3U Configuration</h4>
                <div class="settings-group">
                    <label class="settings-label">M3U File Name</label>
                    <input type="text" id="m3u-file-name" class="settings-input" placeholder="channels_filtered.m3u">
                </div>
                <div class="settings-group">
                    <label class="settings-label">M3U URL (for remote playlists)</label>
                    <input type="url" id="m3u-url" class="settings-input" placeholder="http://example.com/playlist.m3u">
                </div>
            </div>

            <div class="settings-section">
                <h4>🌐 Server Configuration</h4>
                <div class="settings-group">
                    <label class="settings-label">HTTP Server Port</label>
                    <input type="number" id="http-port" class="settings-input" placeholder="8080" min="1000" max="65535">
                </div>
                <div class="settings-group">
                    <label class="settings-label">EPG Server Port</label>
                    <input type="number" id="epg-port" class="settings-input" placeholder="3001" min="1000" max="65535">
                </div>
            </div>

            <div class="settings-section">
                <h4>📺 EPG Configuration</h4>
                <div class="settings-group">
                    <label class="settings-label">EPG Script Path</label>
                    <input type="text" id="epg-script-path" class="settings-input" placeholder="/path/to/epg_fetch.py">
                </div>
                <div class="settings-group">
                    <label class="settings-label">EPG URL</label>
                    <input type="url" id="epg-url" class="settings-input" placeholder="http://example.com/xmltv.php">
                </div>
                <div class="settings-group">
                    <label class="settings-label">Cache Duration (minutes)</label>
                    <input type="number" id="cache-duration" class="settings-input" placeholder="30" min="1" max="1440">
                </div>
            </div>

            <div class="settings-section">
                <h4>🎨 UI Configuration</h4>
                <div class="settings-group">
                    <label class="settings-label">Theme</label>
                    <select id="theme-select" class="settings-input">
                        <option value="spotify">Spotify Dark</option>
                        <option value="classic">Classic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                <div class="settings-group">
                    <label class="settings-label">Channel Logo Size</label>
                    <select id="logo-size" class="settings-input">
                        <option value="small">Small (24px)</option>
                        <option value="medium" selected>Medium (40px)</option>
                        <option value="large">Large (60px)</option>
                    </select>
                </div>
            </div>

            <div class="settings-section">
                <h4>💾 Data Management</h4>
                <button class="settings-button" id="save-settings">💾 Save Settings</button>
                <button class="settings-button secondary" id="reset-settings">🔄 Reset to Defaults</button>
                <button class="settings-button secondary" id="export-settings">📤 Export Settings</button>
                <button class="settings-button secondary" id="import-settings">📥 Import Settings</button>
            </div>

            <div class="settings-section">
                <h4>🔧 Advanced</h4>
                <button class="settings-button secondary" id="clear-cache">🗑️ Clear EPG Cache</button>
                <button class="settings-button secondary" id="test-epg">🧪 Test EPG Connection</button>
                <button class="settings-button secondary" id="reload-config">🔄 Reload Configuration</button>
            </div>
        </div>
    </div>

    <!-- Samples Modal -->
    <div id="samples-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📺 Sample Playlists</h3>
                <button id="close-samples-modal" class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p>Choose from these sample playlists to test the IPTV player:</p>
                <div class="samples-grid">
                    <div class="sample-item" data-file="samples/playlist_zz_news_en.m3u8">
                        <div class="sample-icon">📰</div>
                        <div class="sample-info">
                            <h4>News Channels</h4>
                            <p>International news channels including Sky News, Euronews, France 24, and more.</p>
                        </div>
                    </div>
                    <div class="sample-item" data-file="samples/playlist_usa.m3u8">
                        <div class="sample-icon">🇺🇸</div>
                        <div class="sample-info">
                            <h4>USA Channels</h4>
                            <p>Popular US television channels and networks.</p>
                        </div>
                    </div>
                    <div class="sample-item" data-file="samples/playlist_uk.m3u8">
                        <div class="sample-icon">🇬🇧</div>
                        <div class="sample-info">
                            <h4>UK Channels</h4>
                            <p>British television channels including BBC, ITV, Channel 4, and more.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept=".m3u,.m3u8" style="display: none;">

    <script>
        class IPTVApp {
            constructor() {
                this.channels = [];
                this.currentChannel = null;
                this.video = null;
                this.hls = null;
                this.mpegts = null;
                this.auroraPlayer = null;
                this.isLoading = false;
                this.epgData = null;
                this.epgPanelVisible = true;
                this.settings = this.loadSettings();
                this.ac3Supported = false;
                this.cleanupTimeout = null;
                this.eventListeners = new Map();
                
                this.initializeApp();
                this.initializeAC3Support();
            }

            initializeApp() {
                this.video = document.getElementById('video-player');
                this.setupEventListeners();
                this.updateStatus('Loading default channels...');
                
                // Add global error handler for CORS and MSE issues
                window.addEventListener('error', (event) => {
                    if (event.message && event.message.includes('CORS')) {
                        console.warn('🚫 Global CORS error detected:', event.message);
                        this.showWarning('CORS policy detected. Use the Native Player button if streams fail to load.');
                    } else if (event.message && event.message.includes('InvalidStateError') && event.message.includes('buffered')) {
                        console.warn('🚫 MSE InvalidStateError detected - preventing error loop');
                        // Prevent the error from propagating to avoid loops
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });
                
                // Add unhandled promise rejection handler
                window.addEventListener('unhandledrejection', (event) => {
                    if (event.reason && event.reason.message && event.reason.message.includes('InvalidStateError')) {
                        console.warn('🚫 Unhandled MSE promise rejection - preventing error loop');
                        event.preventDefault();
                    }
                });

                // Suppress transmuxing worker errors
                const originalConsoleError = console.error;
                console.error = function(...args) {
                    const message = args.join(' ');
                    if (message.includes('Error while initialize transmuxing worker') || 
                        message.includes('fallback to inline transmuxing')) {
                        console.log('ℹ️ Transmuxing worker using inline fallback (this is normal)');
                        return;
                    }
                    originalConsoleError.apply(console, args);
                };
                
                // Auto-load the default M3U file
                this.loadDefaultM3U();
            }

            initializeAC3Support() {
                console.log('🎵 Initializing AC-3 audio support...');
                
                // Check if browser supports AC-3 natively
                const audio = document.createElement('audio');
                const canPlayAC3 = audio.canPlayType('audio/mp4; codecs="ac-3"') || 
                                  audio.canPlayType('audio/mp4; codecs="ac3"') ||
                                  audio.canPlayType('audio/ac3');
                
                if (canPlayAC3 && canPlayAC3 !== '') {
                    console.log('✅ Browser supports AC-3 audio natively');
                    this.ac3Supported = true;
                } else {
                    console.log('❌ Browser does not support AC-3 audio natively');
                    console.log('💡 AC-3 audio will fall back to video-only playback');
                    this.ac3Supported = false;
                }
                
                // Clean up test audio element
                audio.remove();
            }

            addEventListener(element, event, handler) {
                element.addEventListener(event, handler);
                const key = `${element.id || 'unknown'}_${event}`;
                if (!this.eventListeners.has(key)) {
                    this.eventListeners.set(key, []);
                }
                this.eventListeners.get(key).push({ element, event, handler });
            }

            removeAllEventListeners() {
                console.log('🧹 Removing all event listeners...');
                for (const [key, listeners] of this.eventListeners) {
                    for (const { element, event, handler } of listeners) {
                        try {
                            element.removeEventListener(event, handler);
                        } catch (error) {
                            console.warn(`⚠️ Error removing event listener for ${key}:`, error);
                        }
                    }
                }
                this.eventListeners.clear();
            }

            nextChannel() {
                if (this.channels.length === 0) {
                    console.log('❌ No channels available for navigation');
                    return;
                }
                
                let currentIndex = this.channels.findIndex(ch => ch === this.currentChannel);
                console.log(`🔄 Next channel - Current index: ${currentIndex}, Total channels: ${this.channels.length}`);
                
                if (currentIndex === -1) {
                    currentIndex = 0;
                    console.log('📺 No current channel, selecting first channel');
                } else {
                    currentIndex = (currentIndex + 1) % this.channels.length;
                    console.log(`📺 Moving to next channel, new index: ${currentIndex}`);
                }
                
                const nextChannel = this.channels[currentIndex];
                console.log(`📺 Next channel: ${nextChannel.name}`);
                this.selectChannel(nextChannel);
                this.scrollToChannel(nextChannel);
            }

            previousChannel() {
                if (this.channels.length === 0) {
                    console.log('❌ No channels available for navigation');
                    return;
                }
                
                let currentIndex = this.channels.findIndex(ch => ch === this.currentChannel);
                console.log(`🔄 Previous channel - Current index: ${currentIndex}, Total channels: ${this.channels.length}`);
                
                if (currentIndex === -1) {
                    currentIndex = this.channels.length - 1;
                    console.log('📺 No current channel, selecting last channel');
                } else {
                    currentIndex = currentIndex === 0 ? this.channels.length - 1 : currentIndex - 1;
                    console.log(`📺 Moving to previous channel, new index: ${currentIndex}`);
                }
                
                const prevChannel = this.channels[currentIndex];
                console.log(`📺 Previous channel: ${prevChannel.name}`);
                this.selectChannel(prevChannel);
                this.scrollToChannel(prevChannel);
            }

            selectChannel(channel) {
                console.log(`🎯 Selecting channel: ${channel.name} (ID: ${channel.id})`);
                
                // Remove highlight from all channels
                document.querySelectorAll('.channel-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add highlight to selected channel
                const channelElement = document.querySelector(`[data-channel-id="${channel.id}"]`);
                if (channelElement) {
                    channelElement.classList.add('selected');
                    console.log(`✅ Channel element found and highlighted`);
                } else {
                    console.log(`❌ Channel element not found for ID: ${channel.id}`);
                }
                
                this.currentChannel = channel;
                console.log(`📺 Selected channel: ${channel.name}`);
            }

            scrollToChannel(channel) {
                const channelElement = document.querySelector(`[data-channel-id="${channel.id}"]`);
                if (channelElement) {
                    channelElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }
            }

            setupEventListeners() {
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (this.channels.length === 0) return;
                    
                    // Don't interfere with input fields
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    switch(e.key) {
                        case 'ArrowRight':
                        case 'ArrowDown':
                        case ' ':
                            e.preventDefault();
                            this.nextChannel();
                            break;
                        case 'ArrowLeft':
                        case 'ArrowUp':
                            e.preventDefault();
                            this.previousChannel();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (this.currentChannel) {
                                console.log(`⌨️ Enter key pressed - playing current channel: ${this.currentChannel.name}`);
                                this.playChannel(this.currentChannel);
                            } else {
                                console.log('❌ Enter key pressed but no current channel selected');
                            }
                            break;
                    }
                });

                // Load dropdown
                const loadBtn = document.getElementById('load-btn');
                const loadDropdown = document.getElementById('load-dropdown');
                
                loadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('🖱️ Load button clicked');
                    console.log('📋 Dropdown classes before:', loadDropdown.className);
                    loadDropdown.classList.toggle('show');
                    console.log('📋 Dropdown classes after:', loadDropdown.className);
                    console.log('👁️ Dropdown display style:', window.getComputedStyle(loadDropdown).display);
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!loadBtn.contains(e.target) && !loadDropdown.contains(e.target)) {
                        loadDropdown.classList.remove('show');
                    }
                });

                // Dropdown items
                document.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = e.currentTarget.dataset.action;
                        loadDropdown.classList.remove('show');
                        
                        switch (action) {
                            case 'upload':
                                this.showFileUpload();
                                break;
                            case 'default':
                                this.loadDefaultM3U();
                                break;
                            case 'samples':
                                this.showSamplesModal();
                                break;
                        }
                    });
                });

                // File input (hidden)
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        if (e.target.files.length > 0) {
                            this.handleFileSelect(e.target.files[0]);
                        }
                    });
                }

                // Samples modal
                document.getElementById('close-samples-modal').addEventListener('click', () => {
                    this.hideSamplesModal();
                });

                document.getElementById('samples-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'samples-modal') {
                        this.hideSamplesModal();
                    }
                });

                // Sample items
                document.querySelectorAll('.sample-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const filename = item.dataset.file;
                        this.loadSamplePlaylist(filename);
                        this.hideSamplesModal();
                    });
                });

                // Video controls
                document.getElementById('play-pause-btn').addEventListener('click', () => {
                    this.togglePlayPause();
                });

                document.getElementById('mute-btn').addEventListener('click', () => {
                    this.toggleMute();
                });

                document.getElementById('fullscreen-btn').addEventListener('click', () => {
                    this.toggleFullscreen();
                });

                // Native player button
                document.getElementById('native-player-btn').addEventListener('click', () => {
                    if (this.currentChannel && this.currentChannel.url) {
                        this.openInNativePlayer(this.currentChannel.url, this.currentChannel.name);
                    } else {
                        this.showError('No channel selected or URL not available');
                    }
                });

                // Search
                document.getElementById('search-input').addEventListener('input', (e) => {
                    this.filterChannels(e.target.value);
                });

                // EPG toggle
                document.getElementById('epg-toggle').addEventListener('click', () => {
                    this.toggleEPGPanel();
                });

                // EPG refresh
                document.getElementById('epg-refresh').addEventListener('click', () => {
                    this.refreshEPGData();
                });

                // Settings
                document.getElementById('settings-btn').addEventListener('click', () => {
                    this.openSettings();
                });

                document.getElementById('settings-close').addEventListener('click', () => {
                    this.closeSettings();
                });

                document.getElementById('settings-overlay').addEventListener('click', () => {
                    this.closeSettings();
                });

                // Settings buttons
                document.getElementById('save-settings').addEventListener('click', () => {
                    this.saveSettings();
                });

                document.getElementById('reset-settings').addEventListener('click', () => {
                    this.resetSettings();
                });

                document.getElementById('export-settings').addEventListener('click', () => {
                    this.exportSettings();
                });

                document.getElementById('import-settings').addEventListener('click', () => {
                    this.importSettings();
                });

                document.getElementById('clear-cache').addEventListener('click', () => {
                    this.clearEPGCache();
                });

                document.getElementById('test-epg').addEventListener('click', () => {
                    this.testEPGConnection();
                });

                document.getElementById('reload-config').addEventListener('click', () => {
                    this.reloadConfiguration();
                });

                // Video events
                this.video.addEventListener('error', (e) => {
                    this.handleVideoError(e);
                });

                this.video.addEventListener('loadstart', () => {
                    this.updateStatus('Loading stream...');
                });

                this.video.addEventListener('canplay', () => {
                    this.updateStatus('Stream ready');
                });
            }

            async loadDefaultM3U() {
                try {
                    // Use settings for configuration
                    const m3uFileName = this.settings.m3uFileName;
                    const httpPort = this.settings.httpPort;
                    
                    // Try HTTP server first, then fallback to file upload
                    const response = await fetch(`http://localhost:${httpPort}/${m3uFileName}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const content = await response.text();
                    this.channels = await this.parseM3U(content);
                    this.renderChannels();
                    this.updateStatus(`Loaded ${this.channels.length} channels from default playlist`);
                } catch (error) {
                    console.error('Error loading default M3U:', error);
                    this.updateStatus('Ready - Upload an M3U file to start');
                    this.showError(`Failed to load default playlist. Please upload an M3U file manually.`);
                }
            }

            async loadSamplePlaylist(filename) {
                try {
                    this.updateStatus('Loading sample playlist...');
                    this.showLoadingOverlay();
                    
                    const response = await fetch(`http://localhost:${this.settings.httpPort || 8080}/${filename}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const content = await response.text();
                    this.channels = await this.parseM3U(content);
                    this.renderChannels();
                    this.updateStatus(`Loaded ${this.channels.length} channels from ${filename}`);
                } catch (error) {
                    console.error('Error loading sample playlist:', error);
                    this.updateStatus(`Error loading sample playlist: ${error.message}`);
                    this.showError(`Failed to load sample playlist: ${error.message}`);
                } finally {
                    this.hideLoadingOverlay();
                }
            }

            showFileUpload() {
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            showSamplesModal() {
                const modal = document.getElementById('samples-modal');
                if (modal) {
                    modal.style.display = 'flex';
                }
            }

            hideSamplesModal() {
                const modal = document.getElementById('samples-modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }

            async handleFileSelect(file) {
                if (!file) return;
                
                this.updateStatus('Loading M3U file...');
                this.showLoadingOverlay();
                
                try {
                    const content = await this.readFile(file);
                    this.channels = await this.parseM3U(content);
                    this.renderChannels();
                    this.updateStatus(`Loaded ${this.channels.length} channels successfully`);
                } catch (error) {
                    console.error('Error loading M3U file:', error);
                    this.updateStatus(`Error: ${error.message}`);
                    this.showError(`Failed to load M3U file: ${error.message}`);
                } finally {
                    this.hideLoadingOverlay();
                }
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async parseM3U(content) {
                const lines = content.split('\n');
                const channels = [];
                let currentChannel = null;
                let processedLines = 0;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.startsWith('#EXTINF:')) {
                        currentChannel = this.parseExtInf(line);
                    } else if (line && !line.startsWith('#') && currentChannel) {
                        currentChannel.url = line;
                        
                        // Generate ID if none exists
                        if (!currentChannel.id) {
                            currentChannel.id = `channel_${channels.length}`;
                        }
                        
                        channels.push(currentChannel);
                        currentChannel = null;
                    }

                    processedLines++;
                    
                    // Update progress every 10 lines
                    if (processedLines % 10 === 0 || i === lines.length - 1) {
                        const progress = Math.round((processedLines / lines.length) * 100);
                        this.updateProgress({
                            progress: progress,
                            channelsFound: channels.length,
                            currentLine: i + 1,
                            totalLines: lines.length
                        });
                        
                        // Allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                return channels;
            }

            parseExtInf(line) {
                const channel = {
                    name: '',
                    logo: '',
                    group: '',
                    id: '',
                    url: ''
                };

                // Extract tvg-name
                const nameMatch = line.match(/tvg-name="([^"]*)"/);
                if (nameMatch) {
                    channel.name = nameMatch[1];
                }

                // Extract tvg-logo
                const logoMatch = line.match(/tvg-logo="([^"]*)"/);
                if (logoMatch) {
                    channel.logo = logoMatch[1];
                }

                // Extract group-title
                const groupMatch = line.match(/group-title="([^"]*)"/);
                if (groupMatch) {
                    channel.group = groupMatch[1];
                }

                // Extract tvg-id
                const idMatch = line.match(/tvg-id="([^"]*)"/);
                if (idMatch) {
                    channel.id = idMatch[1];
                }

                // If no tvg-name, try to extract from the end of the line
                if (!channel.name) {
                    const parts = line.split(',');
                    if (parts.length > 1) {
                        channel.name = parts[parts.length - 1].trim();
                    }
                }

                // Generate fallback ID if none exists (will be set later with index)
                if (!channel.id) {
                    channel.id = ''; // Will be set in parseM3U with index
                }

                return channel;
            }

            renderChannels() {
                const container = document.getElementById('channels-container');
                
                console.log(`🎬 Rendering ${this.channels.length} channels`);
                
                if (this.channels.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>No channels found in the playlist</p></div>';
                    return;
                }

                container.innerHTML = '';
                
                this.channels.forEach((channel, index) => {
                    console.log(`📺 Creating element for channel ${index}: ${channel.name} (ID: ${channel.id})`);
                    const channelElement = this.createChannelElement(channel);
                    container.appendChild(channelElement);
                });

                // Select first channel by default
                if (this.channels.length > 0 && !this.currentChannel) {
                    console.log(`🎯 Auto-selecting first channel: ${this.channels[0].name}`);
                    this.selectChannel(this.channels[0]);
                }
            }

            createChannelElement(channel) {
                const div = document.createElement('div');
                div.className = 'channel-item';
                div.setAttribute('data-channel-id', channel.id);
                div.addEventListener('click', () => {
                    console.log(`🖱️ Channel clicked: ${channel.name}`);
                    this.selectChannel(channel);
                    this.playChannel(channel);
                });

                const logoDiv = document.createElement('div');
                logoDiv.className = 'channel-logo';
                
                if (channel.logo) {
                    const img = document.createElement('img');
                    img.src = channel.logo;
                    img.alt = channel.name;
                    img.onerror = () => {
                        // Fallback to emoji based on channel name
                        logoDiv.textContent = this.getChannelEmoji(channel.name);
                        logoDiv.style.fontSize = '0.8rem';
                    };
                    logoDiv.appendChild(img);
                } else {
                    logoDiv.textContent = this.getChannelEmoji(channel.name);
                    logoDiv.style.fontSize = '0.8rem';
                }

                const infoDiv = document.createElement('div');
                infoDiv.className = 'channel-info';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'channel-name';
                nameDiv.textContent = channel.name;
                
                const groupDiv = document.createElement('div');
                groupDiv.className = 'channel-group';
                groupDiv.textContent = channel.group || 'Unknown Group';

                infoDiv.appendChild(nameDiv);
                infoDiv.appendChild(groupDiv);

                div.appendChild(logoDiv);
                div.appendChild(infoDiv);

                return div;
            }

            getChannelEmoji(channelName) {
                const name = channelName.toLowerCase();
                if (name.includes('bbc')) return '🇬🇧';
                if (name.includes('itv')) return '📺';
                if (name.includes('sky')) return '☁️';
                if (name.includes('cnn')) return '📰';
                if (name.includes('fox')) return '🦊';
                if (name.includes('disney')) return '🏰';
                if (name.includes('hbo')) return '🎬';
                if (name.includes('netflix')) return '🎭';
                if (name.includes('sport')) return '⚽';
                if (name.includes('news')) return '📺';
                return '📡';
            }

            filterChannels(searchTerm) {
                const channels = document.querySelectorAll('.channel-item');
                const term = searchTerm.toLowerCase();

                channels.forEach(channel => {
                    const name = channel.querySelector('.channel-name').textContent.toLowerCase();
                    const group = channel.querySelector('.channel-group').textContent.toLowerCase();
                    
                    if (name.includes(term) || group.includes(term)) {
                        channel.style.display = 'flex';
                    } else {
                        channel.style.display = 'none';
                    }
                });
            }

            async playChannel(channel) {
                console.log(`🎬 Playing channel: ${channel.name} (URL: ${channel.url})`);
                
                // Don't return early - allow re-playing the same channel
                this.currentChannel = channel;
                this.updateStatus(`Loading ${channel.name}...`);
                
                // Check if this is likely to have CORS issues (external domains)
                const isExternalDomain = !channel.url.includes('localhost') && 
                                       !channel.url.includes('127.0.0.1') && 
                                       (channel.url.includes('http://') || channel.url.includes('https://'));
                
                if (isExternalDomain) {
                    console.log('🌐 External domain detected - may have CORS issues');
                    this.showWarning('External stream detected. If playback fails, use the Native Player button for VLC.');
                }
                
                // Clean up previous HLS instance with delay to prevent MSE errors
                if (this.cleanupTimeout) {
                    clearTimeout(this.cleanupTimeout);
                }
                this.cleanupTimeout = setTimeout(() => {
                    this.cleanupHLS();
                }, 100);
                
                try {
                    await this.playStreamWithHLS(channel.url);
                    this.updateStatus(`Playing ${channel.name}`);
                    
                    // Load EPG for current channel
                    this.loadChannelEPG(channel);
                } catch (error) {
                    console.error('Stream error:', error);
                    this.updateStatus(`Error playing ${channel.name}`);
                    
                    // Check if it's an audio codec issue
                    if (error.message && error.message.includes('AC-3')) {
                        this.showWarning(`Audio codec not supported. Video may play without audio.`);
                    } else if (error.message && error.message.includes('MPEG-TS stream not supported')) {
                        this.showWarning(`MPEG-TS stream not supported by browser. Use the Native Player button to open in VLC.`);
                    } else {
                        this.showError(`Failed to play ${channel.name}: ${error.message}`);
                        
                        // Stream failed - no automatic VLC popup
                    }
                }
            }

            async playStreamWithHLS(url) {
                console.log('🎬 playStreamWithHLS called with URL:', url);
                
                // Check if it's a .m3u8 HLS stream
                if (url.includes('.m3u8') || url.includes('m3u8') || url.endsWith('.m3u8')) {
                    console.log('📺 Detected HLS stream');
                    await this.playHLSStream(url);
                } else if (this.isLikelyMPEGTS(url)) {
                    console.log('📺 Detected MPEG-TS stream');
                    try {
                        await this.playMPEGTSStream(url);
                    } catch (error) {
                        console.log('MPEG-TS failed:', error.message);
                        this.showWarning('MPEG-TS stream not supported by browser. Use the Native Player button to open in VLC.');
                        // Don't try HLS on MPEG-TS streams - it will always fail
                        // Don't throw error, just show warning and let user use Native Player
                        return;
                    }
                } else {
                    console.log('📺 Unknown stream type, trying direct video first');
                    // Try direct video first
                    try {
                        await this.playDirectStream(url);
                    } catch (error) {
                        console.log('Direct stream failed, trying HLS...', error.message);
                        this.showWarning('Direct video failed, trying HLS...');
                        try {
                            await this.playHLSStream(url);
                        } catch (hlsError) {
                            console.log('HLS also failed, trying MPEG-TS...', hlsError.message);
                            this.showWarning('HLS failed, trying MPEG-TS...');
                            await this.playMPEGTSStream(url);
                        }
                    }
                }
            }

            async playAC3AudioStream(url) {
                return new Promise((resolve, reject) => {
                    console.log('🎵 Attempting native AC-3 audio playback:', url);
                    
                    if (!this.ac3Supported) {
                        reject(new Error('AC-3 support not available'));
                        return;
                    }

                    try {
                        // Create a separate audio element for AC-3 audio
                        const audioElement = document.createElement('audio');
                        audioElement.crossOrigin = 'anonymous';
                        audioElement.preload = 'auto';
                        
                        audioElement.addEventListener('canplay', () => {
                            console.log('🎵 AC-3 Audio ready to play');
                            try {
                                audioElement.play();
                                console.log('🎵 AC-3 Audio playback started');
                                resolve();
                            } catch (playError) {
                                console.error('🎵 AC-3 Audio play error:', playError);
                                reject(new Error(`AC-3 Audio play error: ${playError.message}`));
                            }
                        });
                        
                        audioElement.addEventListener('error', (error) => {
                            console.error('🎵 AC-3 Audio error:', error);
                            reject(new Error(`AC-3 Audio error: ${error.message || 'Unknown error'}`));
                        });
                        
                        audioElement.addEventListener('ended', () => {
                            console.log('🎵 AC-3 Audio playback ended');
                        });
                        
                        // Set the source and start loading
                        audioElement.src = url;
                        audioElement.load();
                        
                        // Store reference for cleanup
                        this.auroraPlayer = audioElement;
                        
                    } catch (error) {
                        console.error('🎵 Failed to create AC-3 audio element:', error);
                        reject(new Error(`Failed to create AC-3 audio element: ${error.message}`));
                    }
                });
            }

            async playHLSStream(url) {
                return new Promise((resolve, reject) => {
                    console.log('🎬 Starting HLS playback for:', url);
                    console.log('🔍 HLS available:', typeof Hls !== 'undefined');
                    console.log('🔍 HLS supported:', typeof Hls !== 'undefined' ? Hls.isSupported() : false);
                    
                    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                        this.hls = new Hls({
                            enableWorker: true,
                            lowLatencyMode: true,
                            backBufferLength: 90
                        });
                        
                        this.hls.loadSource(url);
                        this.hls.attachMedia(this.video);
                        
                        this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                            console.log('HLS manifest parsed, starting playback');
                            this.video.play().then(resolve).catch(reject);
                        });
                        
                        this.hls.on(Hls.Events.ERROR, (event, data) => {
                            console.error('HLS error:', data);
                            if (data.fatal) {
                                reject(new Error(`HLS Error: ${data.type} - ${data.details}`));
                            }
                        });
                        
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            if (this.video.readyState < 2) {
                                reject(new Error('HLS stream timeout'));
                            }
                        }, 10000);
                    } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {
                        this.video.src = url;
                        this.video.addEventListener('loadedmetadata', () => {
                            this.video.play().then(resolve).catch(reject);
                        });
                        this.video.addEventListener('error', () => {
                            reject(new Error('Native HLS playback failed'));
                        });
                    } else {
                        reject(new Error('HLS is not supported'));
                    }
                });
            }

            async playMPEGTSStream(url) {
                return new Promise(async (resolve, reject) => {
                    console.log('🎬 Starting MPEG-TS playback for:', url);
                    console.log('🔍 mpegts available:', typeof mpegts !== 'undefined');
                    console.log('🔍 mpegts supported:', typeof mpegts !== 'undefined' ? mpegts.isSupported() : false);
                    
                    // Check for SSL certificate issues and try HTTP fallback
                    if (url.startsWith('https://') && url.includes('streamy.site')) {
                        console.log('🔒 HTTPS URL detected, checking for SSL issues...');
                        const httpUrl = url.replace('https://', 'http://');
                        console.log('🔄 Will try HTTP fallback if HTTPS fails:', httpUrl);
                    }
                    
                    // Test URL accessibility first
                    console.log('🔍 Testing URL accessibility...');
                    try {
                        const testResponse = await fetch(url, { 
                            method: 'HEAD',
                            mode: 'no-cors',
                            cache: 'no-cache'
                        });
                        console.log('✅ URL accessibility test passed');
                    } catch (error) {
                        console.warn('⚠️ URL accessibility test failed:', error.message);
                        console.log('🔄 Proceeding with MPEG-TS anyway...');
                    }
                    
                    if (typeof mpegts !== 'undefined' && mpegts.isSupported()) {
                        console.log('🔧 Creating mpegts player...');
                        this.mpegts = mpegts.createPlayer({
                            type: 'mpegts',
                            url: url,
                            isLive: true,
                            cors: true,
                            withCredentials: false,
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                                'Accept': '*/*',
                                'Accept-Language': 'en-US,en;q=0.9',
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            }
                        }, {
                            enableWorker: true, // Enable worker but with proper configuration
                            enableStashBuffer: false,
                            stashInitialSize: 128,
                            autoCleanupSourceBuffer: true,
                            // Worker configuration to prevent initialization errors
                            workerPath: undefined, // Use default worker path
                            enableWorkerThreads: false, // Disable worker threads to prevent issues
                            // Add CORS handling
                            xhrSetup: (xhr, url) => {
                                xhr.withCredentials = false;
                                xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
                                xhr.setRequestHeader('Accept', '*/*');
                                xhr.setRequestHeader('Accept-Language', 'en-US,en;q=0.9');
                                xhr.setRequestHeader('Cache-Control', 'no-cache');
                                xhr.setRequestHeader('Pragma', 'no-cache');
                            }
                        });
                        console.log('✅ mpegts player created successfully');
                        
                        // Attach media element with error handling
                        try {
                            this.mpegts.attachMediaElement(this.video);
                        } catch (error) {
                            console.warn('⚠️ Error attaching media element:', error);
                            reject(new Error(`Failed to attach media element: ${error.message}`));
                            return;
                        }
                        
                        this.mpegts.on(mpegts.Events.ERROR, (errorType, errorDetail, errorInfo) => {
                            console.error('🚨 mpegts.js error:', errorType, errorDetail, errorInfo);
                            console.error('🚨 Error details:', {
                                type: errorType,
                                detail: errorDetail,
                                info: errorInfo,
                                url: url,
                                readyState: this.video.readyState,
                                networkState: this.video.networkState
                            });
                            
                            // Check for SSL certificate errors
                            const errorMessage = errorInfo && errorInfo.message ? errorInfo.message : '';
                            const isSSLError = (errorType === 'NetworkError') ||
                                             (errorMessage.includes('CERT_COMMON_NAME_INVALID')) ||
                                             (errorMessage.includes('SSL')) ||
                                             (errorMessage.includes('certificate')) ||
                                             (errorMessage.includes('TLS')) ||
                                             (errorDetail && errorDetail.includes('SSL'));
                            
                            if (isSSLError && url.startsWith('https://')) {
                                console.warn('🔒 SSL certificate error detected, trying HTTP fallback...');
                                const httpUrl = url.replace('https://', 'http://');
                                console.log('🔄 Attempting HTTP fallback:', httpUrl);
                                
                                // Try HTTP version
                                this.mpegts.destroy();
                                this.playMPEGTSStream(httpUrl).then(resolve).catch(reject);
                                return;
                            }
                            
                            // Check if it's an audio codec issue - look for AC-3 in various error messages
                            const isAC3Error = (errorDetail && errorDetail.includes('ac-3')) ||
                                             (errorMessage.includes('ac-3')) ||
                                             (errorType === 'MediaMSEError' && errorDetail && errorDetail.includes('codecs=ac-3')) ||
                                             (errorType === 'MediaMSEError' && errorDetail && errorDetail.includes('addSourceBuffer')) ||
                                             (errorMessage.includes('addSourceBuffer') && errorMessage.includes('ac-3')) ||
                                             (errorMessage.includes('audio/mp4;codecs=ac-3'));
                            
                            // Check if it's a CORS/network issue
                            const isCORSError = (errorType === 'NetworkError') ||
                                              (errorMessage.includes('CORS')) ||
                                              (errorMessage.includes('Failed to fetch')) ||
                                              (errorMessage.includes('Access-Control-Allow-Origin')) ||
                                              (errorDetail && errorDetail.includes('Failed to fetch')) ||
                                              (errorDetail && errorDetail.includes('Exception')) ||
                                              (errorType === 'NetworkError' && errorDetail === 'Exception');
                            
                            if (isCORSError) {
                                console.warn('🚫 CORS/Network error detected');
                                this.showWarning('CORS policy blocking stream access. Trying alternative methods...');
                                
                                // Try direct video element as fallback
                                console.log('🔄 Attempting direct video playback as CORS fallback');
                                this.video.src = url;
                                this.video.load();
                                
                                // Wait to see if direct playback works
                                setTimeout(() => {
                                    if (this.video.readyState >= 2) { // HAVE_CURRENT_DATA
                                        console.log('✅ Direct video playback successful (CORS bypassed)');
                                        this.showSuccess('Stream playing via direct video element');
                                        resolve();
                                    } else {
                                        console.log('❌ Direct video playback also failed');
                                        
                                        // CORS error - no automatic VLC popup
                                        
                                        this.showError('Stream blocked by CORS policy. Use the Native Player button to open in VLC.');
                                        reject(new Error(`CORS policy blocking stream access: ${errorDetail}`));
                                    }
                                }, 3000);
                                
                            } else if (isAC3Error) {
                                console.warn('🔊 AC-3 audio codec detected');
                                
                                if (this.ac3Supported) {
                                    console.log('🎵 Attempting native AC-3 audio playback');
                                    
                                    // Try to play AC-3 audio natively
                                    this.playAC3AudioStream(url).then(() => {
                                        console.log('✅ AC-3 audio started successfully');
                                        this.showSuccess('AC-3 audio is playing natively');
                                        
                                        // Wait for video to load
                                        setTimeout(() => {
                                            if (this.video.readyState >= 2) { // HAVE_CURRENT_DATA
                                                console.log('✅ Video and AC-3 audio both playing successfully');
                                                resolve();
                                            } else {
                                                console.log('⚠️ AC-3 audio working but video not ready');
                                                resolve(); // Still resolve since audio is working
                                            }
                                        }, 2000);
                                    }).catch((ac3Error) => {
                                        console.warn('❌ Native AC-3 audio failed:', ac3Error);
                                        this.showWarning('AC-3 audio codec not supported. Video will play without audio.');
                                        
                                        // Still try to play video without audio
                                        setTimeout(() => {
                                            if (this.video.readyState >= 2) { // HAVE_CURRENT_DATA
                                                console.log('✅ Video is playing successfully (without audio)');
                                                resolve();
                                            } else {
                                                reject(new Error(`Audio codec (AC-3) not supported. Video may play without audio.`));
                                            }
                                        }, 3000);
                                    });
                                } else {
                                    console.warn('❌ AC-3 support not available - video will play without audio');
                                    this.showWarning('AC-3 audio codec not supported by your browser. Video will play without audio.');
                                    
                                    // Try to disable audio track in mpegts.js to prevent errors
                                    try {
                                        if (this.mpegts && this.mpegts.mediaInfo && this.mpegts.mediaInfo.audioTracks) {
                                            console.log('🔇 Attempting to disable AC-3 audio track');
                                            // This might help prevent the error from recurring
                                        }
                                    } catch (e) {
                                        console.log('Could not modify audio tracks:', e);
                                    }
                                    
                                    // Don't reject immediately for AC-3 issues, let it try to play video
                                    setTimeout(() => {
                                        if (this.video.readyState >= 2) { // HAVE_CURRENT_DATA
                                            console.log('✅ Video is playing successfully (without audio)');
                                            resolve(); // Video is working, resolve the promise
                                        } else {
                                            reject(new Error(`Audio codec (AC-3) not supported. Video may play without audio.`));
                                        }
                                    }, 3000);
                                }
                            } else {
                                reject(new Error(`MPEG-TS Error: ${errorType} - ${errorDetail}`));
                            }
                        });
                        
                        this.mpegts.on(mpegts.Events.MEDIA_INFO, (mediaInfo) => {
                            console.log('Media info:', mediaInfo);
                            
                            // Check for audio codec support
                            if (mediaInfo.audioTracks && mediaInfo.audioTracks.length > 0) {
                                const audioTrack = mediaInfo.audioTracks[0];
                                if (audioTrack.codec && audioTrack.codec.includes('ac-3')) {
                                    console.warn('AC-3 audio detected - may not be supported by browser');
                                    this.showWarning('AC-3 audio codec detected. Video will play but audio may not work.');
                                }
                            }
                        });
                        
                        // Add progress tracking
                        let loadStarted = false;
                        let mediaInfoReceived = false;
                        
                        this.mpegts.on(mpegts.Events.MEDIA_INFO, (mediaInfo) => {
                            console.log('📺 MPEG-TS Media Info received:', mediaInfo);
                            mediaInfoReceived = true;
                        });
                        
                        this.mpegts.on(mpegts.Events.STATISTICS_INFO, (statisticsInfo) => {
                            if (!loadStarted) {
                                console.log('📊 MPEG-TS Statistics Info received - stream is loading');
                                loadStarted = true;
                            }
                        });
                        
                        this.mpegts.load();
                        console.log('🔄 MPEG-TS load() called for URL:', url);
                        
                        // Show loading progress
                        this.showWarning('Loading MPEG-TS stream... This may take a few seconds.');
                        
                        this.video.addEventListener('canplay', () => {
                            console.log('✅ MPEG-TS video can play - starting playback');
                            this.video.play().then(resolve).catch(reject);
                        });
                        
                        // Timeout after 20 seconds (increased for MPEG-TS streams)
                        const timeoutId = setTimeout(async () => {
                            if (this.video.readyState < 2) {
                                console.log('⏰ MPEG-TS timeout - readyState:', this.video.readyState);
                                console.log('📊 Load started:', loadStarted, 'Media info received:', mediaInfoReceived);
                                
                                // Try direct video playback as fallback
                                console.log('🔄 MPEG-TS failed, trying direct video playback...');
                                try {
                                    await this.playDirectStream(url);
                                    resolve(); // Success with direct playback
                                    return;
                                } catch (directError) {
                                    console.log('❌ Direct playback also failed:', directError.message);
                                }
                                
                                reject(new Error('MPEG-TS stream timeout - stream took too long to start. Try using the Native Player button for VLC.'));
                            }
                        }, 20000);
                        
                        // Clear timeout if video starts playing
                        this.video.addEventListener('canplay', () => {
                            clearTimeout(timeoutId);
                        });
                    } else {
                        reject(new Error('mpegts.js is not supported'));
                    }
                });
            }

            async playDirectStream(url) {
                return new Promise((resolve, reject) => {
                    console.log('🎬 Attempting direct video playback:', url);
                    
                    // Check for SSL certificate issues and try HTTP fallback
                    if (url.startsWith('https://') && url.includes('streamy.site')) {
                        console.log('🔒 HTTPS URL detected, will try HTTP fallback if needed');
                    }
                    
                    this.video.src = url;
                    this.video.load();
                    
                    const cleanup = () => {
                        this.video.removeEventListener('canplay', onCanPlay);
                        this.video.removeEventListener('error', onError);
                        this.video.removeEventListener('loadstart', onLoadStart);
                    };
                    
                    const onCanPlay = () => {
                        console.log('✅ Direct video can play');
                        cleanup();
                        this.video.play().then(() => {
                            console.log('✅ Direct video playback started');
                            resolve();
                        }).catch((playError) => {
                            console.error('❌ Direct video play failed:', playError);
                            reject(new Error(`Direct video play failed: ${playError.message}`));
                        });
                    };
                    
                    const onError = (e) => {
                        console.error('❌ Direct video error:', e);
                        const error = this.video.error;
                        let errorMessage = 'Direct stream playback failed';
                        
                        // Check for SSL certificate errors
                        if (url.startsWith('https://') && (errorMessage.includes('SSL') || errorMessage.includes('certificate') || errorMessage.includes('CERT_COMMON_NAME_INVALID'))) {
                            console.warn('🔒 SSL certificate error detected, trying HTTP fallback...');
                            const httpUrl = url.replace('https://', 'http://');
                            console.log('🔄 Attempting HTTP fallback:', httpUrl);
                            
                            cleanup();
                            this.playDirectStream(httpUrl).then(resolve).catch(reject);
                            return;
                        }
                        
                        if (error) {
                            switch (error.code) {
                                case MediaError.MEDIA_ERR_ABORTED:
                                    errorMessage = 'Video playback was aborted';
                                    break;
                                case MediaError.MEDIA_ERR_NETWORK:
                                    errorMessage = 'Network error while loading video';
                                    break;
                                case MediaError.MEDIA_ERR_DECODE:
                                    errorMessage = 'Video format not supported or decode error';
                                    break;
                                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                    errorMessage = 'Video format not supported by browser';
                                    break;
                                default:
                                    errorMessage = `Video error: ${error.message || 'Unknown error'}`;
                            }
                        }
                        
                        cleanup();
                        reject(new Error(errorMessage));
                    };
                    
                    const onLoadStart = () => {
                        console.log('🔄 Direct video load started');
                    };
                    
                    this.video.addEventListener('canplay', onCanPlay);
                    this.video.addEventListener('error', onError);
                    this.video.addEventListener('loadstart', onLoadStart);
                    
                    // Timeout after 15 seconds
                    setTimeout(() => {
                        if (this.video.readyState < 2) {
                            console.log('⏰ Direct video timeout - readyState:', this.video.readyState);
                            cleanup();
                            reject(new Error('Direct stream timeout - video not ready'));
                        }
                    }, 15000);
                });
            }

            isLikelyMPEGTS(url) {
                const mpegtsPatterns = [
                    /\.ts$/i,
                    /mpegts/i,
                    /transport/i,
                    /streamy\.site/i,
                    /get\.php.*output=ts/i
                ];
                
                return mpegtsPatterns.some(pattern => pattern.test(url));
            }

            cleanupHLS() {
                console.log('🧹 Cleaning up media players...');
                
                // Clean up HLS
                if (this.hls) {
                    try {
                        this.hls.destroy();
                        console.log('✅ HLS destroyed');
                    } catch (error) {
                        console.warn('⚠️ Error destroying HLS:', error);
                    }
                    this.hls = null;
                }
                
                // Clean up MPEG-TS
                if (this.mpegts) {
                    try {
                        this.mpegts.destroy();
                        console.log('✅ MPEG-TS destroyed');
                    } catch (error) {
                        console.warn('⚠️ Error destroying MPEG-TS:', error);
                    }
                    this.mpegts = null;
                }
                
                // Clean up Aurora player
                if (this.auroraPlayer) {
                    try {
                        if (this.auroraPlayer.pause) {
                            this.auroraPlayer.pause();
                        }
                        if (this.auroraPlayer.remove) {
                            this.auroraPlayer.remove();
                        }
                        console.log('✅ Aurora player cleaned up');
                    } catch (error) {
                        console.warn('⚠️ Error cleaning up Aurora player:', error);
                    }
                    this.auroraPlayer = null;
                }
                
                // Clean up video element
                try {
                    // Remove all event listeners to prevent error loops
                    this.removeAllEventListeners();
                    
                    // Clear the source
                    this.video.src = '';
                    this.video.srcObject = null;
                    
                    // Reset video properties
                    this.video.currentTime = 0;
                    this.video.load();
                    
                    console.log('✅ Video element cleaned up');
                } catch (error) {
                    console.warn('⚠️ Error cleaning up video element:', error);
                }
                
                // Clear any pending timeouts
                if (this.cleanupTimeout) {
                    clearTimeout(this.cleanupTimeout);
                    this.cleanupTimeout = null;
                }
            }

            togglePlayPause() {
                if (this.video.paused) {
                    this.video.play();
                    document.getElementById('play-pause-btn').textContent = '⏸️ Pause';
                } else {
                    this.video.pause();
                    document.getElementById('play-pause-btn').textContent = '▶️ Play';
                }
            }

            toggleMute() {
                this.video.muted = !this.video.muted;
                document.getElementById('mute-btn').textContent = this.video.muted ? '🔊 Unmute' : '🔇 Mute';
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    this.video.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            updateStatus(message) {
                document.getElementById('status-text').textContent = message;
            }

            showLoadingOverlay() {
                document.getElementById('loading-overlay').style.display = 'flex';
            }

            hideLoadingOverlay() {
                document.getElementById('loading-overlay').style.display = 'none';
            }

            updateProgress({ progress, channelsFound, currentLine, totalLines }) {
                const loadingText = document.getElementById('loading-text');
                loadingText.textContent = `Loading... ${progress}% (${channelsFound} channels found)`;
            }

            showError(message) {
                const errorDiv = document.getElementById('error-message');
                const errorText = errorDiv.querySelector('.error-text');
                errorText.textContent = message;
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }

            showWarning(message) {
                const errorDiv = document.getElementById('error-message');
                const errorText = errorDiv.querySelector('.error-text');
                errorText.textContent = `⚠️ ${message}`;
                errorDiv.style.display = 'block';
                errorDiv.style.backgroundColor = '#ffa500';
                errorDiv.style.color = '#000';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.style.backgroundColor = '#ff4444';
                    errorDiv.style.color = '#fff';
                }, 4000);
            }

            showSuccess(message) {
                const errorDiv = document.getElementById('error-message');
                const errorText = errorDiv.querySelector('.error-text');
                errorText.textContent = `✅ ${message}`;
                errorDiv.style.display = 'block';
                errorDiv.style.backgroundColor = '#1db954';
                errorDiv.style.color = '#fff';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.style.backgroundColor = '#ff4444';
                    errorDiv.style.color = '#fff';
                }, 3000);
            }

            openInNativePlayer(url, channelName) {
                console.log('🎬 Opening stream in VLC:', url);
                
                // Try multiple methods to open VLC specifically
                let opened = false;
                
                // Method 1: VLC protocol (vlc://)
                try {
                    const vlcUrl = `vlc://${url}`;
                    const link = document.createElement('a');
                    link.href = vlcUrl;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.click();
                    opened = true;
                    console.log('✅ Opened via VLC protocol');
                } catch (error) {
                    console.log('❌ VLC protocol method failed:', error);
                }
                
                // Method 2: Try VLC with different protocol format
                if (!opened) {
                    try {
                        const vlcUrl = `vlc://${url.replace(/^https?:\/\//, '')}`;
                        const link = document.createElement('a');
                        link.href = vlcUrl;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.click();
                        opened = true;
                        console.log('✅ Opened via VLC protocol (alternative format)');
                    } catch (error) {
                        console.log('❌ VLC protocol alternative failed:', error);
                    }
                }
                
                // Method 3: Direct link (fallback to system default)
                if (!opened) {
                    try {
                        const link = document.createElement('a');
                        link.href = url;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.click();
                        opened = true;
                        console.log('✅ Opened via direct link (system default)');
                    } catch (error) {
                        console.log('❌ Direct link method failed:', error);
                    }
                }
                
                // Method 4: Window.open (alternative method)
                if (!opened) {
                    try {
                        window.open(url, '_blank');
                        opened = true;
                        console.log('✅ Opened via window.open');
                    } catch (error) {
                        console.log('❌ Window.open method failed:', error);
                    }
                }
                
                if (opened) {
                    // Show success message
                    this.showSuccess(`Opening "${channelName}" in VLC media player...`);
                    
                    // Copy URL to clipboard for manual use
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(url).then(() => {
                            console.log('📋 Stream URL copied to clipboard');
                        }).catch(() => {
                            console.log('📋 Could not copy URL to clipboard');
                        });
                    }
                    
                    // Also show instructions for manual VLC opening
                    setTimeout(() => {
                        this.showWarning('If VLC didn\'t open automatically, you can: 1) Copy the URL from clipboard, 2) Open VLC manually, 3) Go to Media > Open Network Stream, 4) Paste the URL');
                    }, 3000);
                    
                } else {
                    // All methods failed, show error with URL and manual instructions
                    this.showError(`Failed to open VLC automatically. Stream URL: ${url}`);
                    console.error('❌ All VLC opening methods failed');
                    
                    // Copy URL to clipboard for manual use
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(url).then(() => {
                            console.log('📋 Stream URL copied to clipboard for manual use');
                        });
                    }
                }
            }

            handleVideoError(event) {
                const error = event.target.error;
                let message = 'Unknown video error';
                
                if (error) {
                    switch (error.code) {
                        case error.MEDIA_ERR_ABORTED:
                            message = 'Video playback was aborted';
                            break;
                        case error.MEDIA_ERR_NETWORK:
                            message = 'Network error occurred';
                            break;
                        case error.MEDIA_ERR_DECODE:
                            message = 'Video decoding error';
                            break;
                        case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            message = 'Video format not supported';
                            break;
                    }
                }
                
                this.updateStatus(`Video Error: ${message}`);
                this.showError(message);
            }

            toggleEPGPanel() {
                const epgPanel = document.getElementById('epg-panel');
                const epgToggle = document.getElementById('epg-toggle');
                
                this.epgPanelVisible = !this.epgPanelVisible;
                
                if (this.epgPanelVisible) {
                    epgPanel.classList.remove('collapsed');
                    epgToggle.textContent = 'Hide';
                } else {
                    epgPanel.classList.add('collapsed');
                    epgToggle.textContent = 'Show';
                }
            }

            async loadChannelEPG(channel, forceRefresh = false) {
                const epgContent = document.getElementById('epg-content');
                
                // Show loading state
                epgContent.innerHTML = `
                    <div class="epg-loading">
                        <p>Loading EPG for ${channel.name}...</p>
                    </div>
                `;

                try {
                    // Get channel ID for EPG lookup using the exact tvg-id from M3U
                    const channelId = this.extractChannelId(channel);
                    
                    if (!channelId) {
                        epgContent.innerHTML = `
                            <div class="epg-error">
                                <p>No EPG data available for this channel</p>
                            </div>
                        `;
                        return;
                    }

                    console.log(`Fetching EPG for channel ID: ${channelId}`);
                    
                    // Check cache first (unless force refresh)
                    if (!forceRefresh) {
                        const cachedData = this.getCachedEPGData(channelId);
                        if (cachedData) {
                            console.log('📺 Using cached EPG data');
                            this.displayEPGData(channel, cachedData.programmes, true, cachedData.timestamp);
                            return;
                        }
                    }
                    
                    // Call Python script to get EPG data
                    const epgResponse = await this.fetchEPGData(channelId);
                    
                    // Cache the data
                    this.cacheEPGData(channelId, epgResponse.programmes);
                    
                    this.displayEPGData(channel, epgResponse.programmes, epgResponse.cached);
                    
                } catch (error) {
                    console.error('Error loading EPG:', error);
                    epgContent.innerHTML = `
                        <div class="epg-error">
                            <p>Failed to load EPG data</p>
                            <p style="font-size: 0.8rem; color: #a0a0a0;">${error.message}</p>
                        </div>
                    `;
                }
            }

            extractChannelId(channel) {
                // Use the tvg-id from the M3U file if available
                if (channel.id && channel.id.trim()) {
                    return channel.id.trim();
                }
                
                // Fallback: try to extract channel ID from common patterns in the name
                const channelName = channel.name || '';
                const patterns = [
                    /bbc\s*(\d+)/i,
                    /itv\s*(\d+)/i,
                    /channel\s*(\d+)/i,
                    /sky\s*(\d+)/i
                ];
                
                for (const pattern of patterns) {
                    const match = channelName.match(pattern);
                    if (match) {
                        return match[0].toLowerCase().replace(/\s+/g, '');
                    }
                }
                
                // Return a simplified version of the channel name
                return channelName.toLowerCase()
                    .replace(/[^a-z0-9]/g, '')
                    .substring(0, 20);
            }

            async fetchEPGData(channelId) {
                try {
                    const epgPort = this.settings.epgPort;
                    const response = await fetch(`http://localhost:${epgPort}/api/epg/${encodeURIComponent(channelId)}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        return {
                            programmes: data.programmes,
                            cached: data.cached || false
                        };
                    } else {
                        throw new Error(data.error || 'Failed to fetch EPG data');
                    }
                } catch (error) {
                    console.error('EPG fetch error:', error);
                    
                    // Fallback to mock data if server is not available
                    console.log('Using mock EPG data as fallback');
                    return {
                        programmes: [
                            {
                                start: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
                                stop: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
                                title: 'Current Programme'
                            },
                            {
                                start: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
                                stop: new Date(Date.now() + 90 * 60 * 1000).toISOString(),
                                title: 'Next Programme'
                            },
                            {
                                start: new Date(Date.now() + 90 * 60 * 1000).toISOString(),
                                stop: new Date(Date.now() + 150 * 60 * 1000).toISOString(),
                                title: 'Evening Show'
                            }
                        ],
                        cached: false
                    };
                }
            }

            // EPG Caching Methods
            getCachedEPGData(channelId) {
                try {
                    const cacheKey = `epg_${channelId}`;
                    const cached = localStorage.getItem(cacheKey);
                    
                    if (!cached) {
                        return null;
                    }
                    
                    const data = JSON.parse(cached);
                    const now = new Date().getTime();
                    const cacheAge = now - data.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    
                    if (cacheAge > maxAge) {
                        console.log('📺 EPG cache expired, removing');
                        localStorage.removeItem(cacheKey);
                        return null;
                    }
                    
                    console.log(`📺 EPG cache hit for ${channelId}, age: ${Math.round(cacheAge / 1000 / 60)} minutes`);
                    return data;
                } catch (error) {
                    console.error('Error reading EPG cache:', error);
                    return null;
                }
            }

            cacheEPGData(channelId, programmes) {
                try {
                    const cacheKey = `epg_${channelId}`;
                    const data = {
                        programmes: programmes,
                        timestamp: new Date().getTime()
                    };
                    
                    localStorage.setItem(cacheKey, JSON.stringify(data));
                    console.log(`📺 EPG data cached for ${channelId}`);
                } catch (error) {
                    console.error('Error caching EPG data:', error);
                }
            }

            refreshEPGData() {
                if (this.currentChannel) {
                    console.log('🔄 Refreshing EPG data for current channel');
                    this.loadChannelEPG(this.currentChannel, true); // Force refresh
                } else {
                    this.showWarning('No channel selected for EPG refresh');
                }
            }

            // Helper method to test URL accessibility
            async testStreamURL(url) {
                try {
                    console.log('🔍 Testing stream URL:', url);
                    const response = await fetch(url, { 
                        method: 'HEAD',
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    console.log('✅ Stream URL is accessible');
                    return true;
                } catch (error) {
                    console.warn('⚠️ Stream URL test failed:', error.message);
                    return false;
                }
            }

            // Helper method to get cache status display
            getCacheStatusDisplay(isCached, cacheTimestamp) {
                if (!isCached) {
                    return '<div style="font-size: 0.8rem; color: #60a5fa;">🔄 Live data</div>';
                }
                
                if (cacheTimestamp) {
                    const now = new Date().getTime();
                    const cacheAge = now - cacheTimestamp;
                    const ageMinutes = Math.round(cacheAge / 1000 / 60);
                    const ageHours = Math.round(cacheAge / 1000 / 60 / 60);
                    
                    let ageText;
                    if (ageMinutes < 60) {
                        ageText = `${ageMinutes}m ago`;
                    } else {
                        ageText = `${ageHours}h ago`;
                    }
                    
                    return `<div style="font-size: 0.8rem; color: #4ade80;">💾 Cached (${ageText})</div>`;
                }
                
                return '<div style="font-size: 0.8rem; color: #4ade80;">💾 Cached data</div>';
            }

            displayEPGData(channel, epgData, isCached = false, cacheTimestamp = null) {
                const epgContent = document.getElementById('epg-content');
                const now = new Date();
                
                let html = `
                    <div class="epg-channel-info">
                        <div class="epg-channel-name">📺 ${channel.name}</div>
                        ${this.getCacheStatusDisplay(isCached, cacheTimestamp)}
                    </div>
                `;

                // Find current programme
                const currentProgramme = epgData.find(prog => {
                    const start = new Date(prog.start);
                    const stop = new Date(prog.stop);
                    return now >= start && now <= stop;
                });

                if (currentProgramme) {
                    const startTime = new Date(currentProgramme.start).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    const endTime = new Date(currentProgramme.stop).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    html += `
                        <div class="epg-current-programme">
                            <h4>🔴 NOW</h4>
                            <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">${currentProgramme.title}</div>
                            <div style="font-size: 0.9rem; color: #a0a0a0;">${startTime} - ${endTime}</div>
                        </div>
                    `;
                }

                html += '<div class="epg-programme-list">';
                
                epgData.forEach((programme, index) => {
                    const start = new Date(programme.start);
                    const stop = new Date(programme.stop);
                    const isCurrent = now >= start && now <= stop;
                    
                    const startTime = start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    const endTime = stop.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    html += `
                        <div class="epg-programme-item ${isCurrent ? 'current' : ''}">
                            <div class="epg-programme-time">${startTime} - ${endTime}</div>
                            <div class="epg-programme-title">${programme.title}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                epgContent.innerHTML = html;
            }

            // Settings Management
            loadSettings() {
                const defaultSettings = {
                    m3uFileName: 'channels_filtered.m3u',
                    m3uUrl: '',
                    httpPort: '8080',
                    epgPort: '3001',
                    epgScriptPath: '/Users/harshalkutkar/epg_fetch.py',
                    epgUrl: '',
                    cacheDuration: 30,
                    theme: 'spotify',
                    logoSize: 'medium'
                };

                try {
                    const saved = localStorage.getItem('iptv-settings');
                    return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
                } catch (error) {
                    console.error('Error loading settings:', error);
                    return defaultSettings;
                }
            }

            saveSettings() {
                const settings = {
                    m3uFileName: document.getElementById('m3u-file-name').value || 'channels_filtered.m3u',
                    m3uUrl: document.getElementById('m3u-url').value,
                    httpPort: document.getElementById('http-port').value || '8080',
                    epgPort: document.getElementById('epg-port').value || '3001',
                    epgScriptPath: document.getElementById('epg-script-path').value || '/Users/harshalkutkar/epg_fetch.py',
                    epgUrl: document.getElementById('epg-url').value,
                    cacheDuration: parseInt(document.getElementById('cache-duration').value) || 30,
                    theme: document.getElementById('theme-select').value,
                    logoSize: document.getElementById('logo-size').value
                };

                this.settings = settings;
                localStorage.setItem('iptv-settings', JSON.stringify(settings));
                this.updateStatus('Settings saved successfully');
                this.showError('Settings saved successfully', 'success');
            }

            resetSettings() {
                if (confirm('Are you sure you want to reset all settings to defaults?')) {
                    localStorage.removeItem('iptv-settings');
                    this.settings = this.loadSettings();
                    this.populateSettingsForm();
                    this.updateStatus('Settings reset to defaults');
                    this.showError('Settings reset to defaults', 'success');
                }
            }

            exportSettings() {
                const dataStr = JSON.stringify(this.settings, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'iptv-settings.json';
                link.click();
                URL.revokeObjectURL(url);
            }

            importSettings() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const settings = JSON.parse(e.target.result);
                                this.settings = { ...this.settings, ...settings };
                                localStorage.setItem('iptv-settings', JSON.stringify(this.settings));
                                this.populateSettingsForm();
                                this.updateStatus('Settings imported successfully');
                                this.showError('Settings imported successfully', 'success');
                            } catch (error) {
                                this.showError('Invalid settings file');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            clearEPGCache() {
                fetch(`http://localhost:${this.settings.epgPort}/api/cache`, { method: 'DELETE' })
                    .then(response => response.json())
                    .then(data => {
                        this.updateStatus('EPG cache cleared');
                        this.showError('EPG cache cleared', 'success');
                    })
                    .catch(error => {
                        this.showError('Failed to clear EPG cache');
                    });
            }

            testEPGConnection() {
                const testChannel = 'bbcone.nl';
                fetch(`http://localhost:${this.settings.epgPort}/api/epg/${testChannel}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            this.updateStatus('EPG connection test successful');
                            this.showError('EPG connection test successful', 'success');
                        } else {
                            this.showError('EPG connection test failed: ' + data.error);
                        }
                    })
                    .catch(error => {
                        this.showError('EPG connection test failed: ' + error.message);
                    });
            }

            reloadConfiguration() {
                // Reload the page to apply new settings
                window.location.reload();
            }

            openSettings() {
                this.populateSettingsForm();
                document.getElementById('settings-panel').classList.add('open');
                document.getElementById('settings-overlay').classList.add('open');
            }

            closeSettings() {
                document.getElementById('settings-panel').classList.remove('open');
                document.getElementById('settings-overlay').classList.remove('open');
            }

            populateSettingsForm() {
                document.getElementById('m3u-file-name').value = this.settings.m3uFileName;
                document.getElementById('m3u-url').value = this.settings.m3uUrl;
                document.getElementById('http-port').value = this.settings.httpPort;
                document.getElementById('epg-port').value = this.settings.epgPort;
                document.getElementById('epg-script-path').value = this.settings.epgScriptPath;
                document.getElementById('epg-url').value = this.settings.epgUrl;
                document.getElementById('cache-duration').value = this.settings.cacheDuration;
                document.getElementById('theme-select').value = this.settings.theme;
                document.getElementById('logo-size').value = this.settings.logoSize;
            }

            showError(message, type = 'error') {
                const errorDiv = document.getElementById('error-message');
                const errorText = errorDiv.querySelector('.error-text');
                errorText.textContent = message;
                
                if (type === 'success') {
                    errorDiv.style.background = '#1db954';
                } else {
                    errorDiv.style.background = '#ff4757';
                }
                
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 3000);
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.iptvApp = new IPTVApp();
        });
    </script>
</body>
</html>
